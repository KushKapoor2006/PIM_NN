#!/usr/bin/env python3
# generate_gantt.py
# Reads the trace CSV generated by rigorous_control_plane_sim_final.py
# and produces a Gantt chart visualization.

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import os
from matplotlib.patches import Patch # For custom legend entries

def plot_gantt_chart(csv_path='simulation/results/traces.csv',
                     output_dir='simulation/results'):
    """
    Reads the detailed trace CSV and generates a comparative Gantt chart
    visualizing the timelines of the Micromanagement vs. Sequencer approaches.
    """
    try:
        df = pd.read_csv(csv_path)
    except FileNotFoundError:
        print(f"Error: Trace file '{csv_path}' not found.")
        print("Please run the main simulation script first to generate the trace.")
        return
    except Exception as e:
        print(f"Error reading CSV file: {e}")
        return

    mic_df = df[df['mode'] == 'micromanagement'].copy()
    seq_df = df[df['mode'] == 'sequencer'].copy()

    if mic_df.empty and seq_df.empty:
        print("Error: No data found in trace file for either mode.")
        return

    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(16, 9), sharex=True) # Slightly taller figure
    fig.suptitle('Timeline Analysis: Micromanagement vs. Hardware Sequencer', fontsize=16, fontweight='bold')

    # --- Define Colors and Y-axis positions ---
    y_labels = ['CPU', 'Bus', 'PIM']
    y_ticks = [1, 2, 3] # Center positions for the bars
    bar_height = 0.5
    
    colors = {
        'CPU_ISSUE': 'deepskyblue',
        'CPU_STALL': 'lightcoral',
        'BUS_CMD': 'salmon',
        'BUS_DATA': 'darkorange',
        'PIM_COMPUTE': 'forestgreen',
        'PIM_IO': 'mediumseagreen',
        'PIM_MICRO': 'palegreen' # For sequencer's internal overhead
    }
    
    # --- Plot 1: Micromanagement ---
    ax1.set_title('Micromanagement: CPU Stalled on Every Operation')
    ax1.set_yticks(y_ticks)
    ax1.set_yticklabels(y_labels)
    ax1.grid(axis='x', linestyle=':', alpha=0.7)
    ax1.set_axisbelow(True)
    max_time_mic = 0

    if not mic_df.empty:
        for _, row in mic_df.iterrows():
            layer = int(row['layer'])
            cmd = row['cmd']
            cpu_start = int(row['cpu_issue_start'])
            cpu_end = int(row['cpu_issue_end'])
            pim_start = int(row['pim_start'])
            pim_end = int(row['pim_end'])
            io_cycles = int(row['io_cycles'])
            compute_cycles = int(row['compute_cycles'])

            # CPU Active issuing command
            ax1.broken_barh([(cpu_start, cpu_end - cpu_start)], (y_ticks[0] - bar_height/2, bar_height), facecolors=colors['CPU_ISSUE'])
            
            # Bus busy transferring command (assume 1 transfer, ending when CPU ends issue)
            bus_cmd_dur = 1 # Simplified, could get from cfg if needed
            bus_cmd_start = cpu_end - bus_cmd_dur
            ax1.broken_barh([(bus_cmd_start, bus_cmd_dur)], (y_ticks[1] - bar_height/2, bar_height), facecolors=colors['BUS_CMD'])

            # PIM Activity
            if io_cycles > 0: # IO Operation
                # Assume IO takes the full PIM time for this command
                ax1.broken_barh([(pim_start, io_cycles)], (y_ticks[2] - bar_height/2, bar_height), facecolors=colors['PIM_IO'])
                # Bus is busy during PIM IO (model as continuous block for simplicity)
                ax1.broken_barh([(pim_start, io_cycles)], (y_ticks[1] - bar_height/2, bar_height), facecolors=colors['BUS_DATA'])
            elif compute_cycles > 0: # Compute Operation
                ax1.broken_barh([(pim_start, compute_cycles)], (y_ticks[2] - bar_height/2, bar_height), facecolors=colors['PIM_COMPUTE'])
                # Bus is IDLE during compute

            # CPU Stall (Time from end of command issue until PIM finishes)
            cpu_stall_start = cpu_end
            cpu_stall_duration = pim_end - cpu_stall_start
            if cpu_stall_duration > 0:
                ax1.broken_barh([(cpu_stall_start, cpu_stall_duration)], (y_ticks[0] - bar_height/2, bar_height), facecolors=colors['CPU_STALL'], alpha=0.7)
            
            max_time_mic = max(max_time_mic, pim_end)
        ax1.set_xlim(0, max_time_mic * 1.05) # Add 5% padding
    else:
        ax1.text(0.5, 0.5, 'No Micromanagement Data', ha='center', va='center', transform=ax1.transAxes)


    # --- Plot 2: Hardware Sequencer ---
    ax2.set_title('Hardware Sequencer: CPU and PIM Overlap')
    ax2.set_yticks(y_ticks)
    ax2.set_yticklabels(y_labels)
    ax2.grid(axis='x', linestyle=':', alpha=0.7)
    ax2.set_axisbelow(True)
    max_time_seq = 0

    if not seq_df.empty:
        for _, row in seq_df.iterrows():
            layer = int(row['layer'])
            cpu_start = int(row['cpu_burst_start'])
            cpu_end = int(row['cpu_burst_end']) # CPU is free after burst write
            exec_issue = int(row['execute_issue_time']) # Time EXECUTE cmd finished on bus
            pim_start = int(row['pim_start'])
            pim_end = int(row['pim_end'])
            io_cycles = int(row['io_cycles'])
            compute_cycles = int(row['compute_cycles'])
            micro_overhead = int(row['micro_overhead'])

            # CPU Active submitting microprogram + EXECUTE command
            ax2.broken_barh([(cpu_start, exec_issue - cpu_start)], (y_ticks[0] - bar_height/2, bar_height), facecolors=colors['CPU_ISSUE'])
            
            # Bus busy during CPU burst write + EXECUTE command transfer
            ax2.broken_barh([(cpu_start, exec_issue - cpu_start)], (y_ticks[1] - bar_height/2, bar_height), facecolors=colors['BUS_CMD'])

            # PIM Activity: IO + Compute + Micro Overhead
            # Approximate IO/Compute distribution for visualization
            if io_cycles + compute_cycles + micro_overhead > 0: # Avoid division by zero
                total_pim_work = io_cycles + compute_cycles + micro_overhead
                
                # IO Phase 1 (Fetch Input + Fetch Weights) - Assume roughly 2/3 of IO
                io1_duration = int(io_cycles * (2/3)) if io_cycles > 0 else 0
                io1_start = pim_start
                ax2.broken_barh([(io1_start, io1_duration)], (y_ticks[2] - bar_height/2, bar_height), facecolors=colors['PIM_IO'])
                # Bus is busy during PIM IO
                ax2.broken_barh([(io1_start, io1_duration)], (y_ticks[1] - bar_height/2, bar_height), facecolors=colors['BUS_DATA'])
                
                # Compute Phase
                compute_start = io1_start + io1_duration
                ax2.broken_barh([(compute_start, compute_cycles)], (y_ticks[2] - bar_height/2, bar_height), facecolors=colors['PIM_COMPUTE'])
                # Bus is idle during compute

                # IO Phase 2 (Store Output) - Assume roughly 1/3 of IO
                io2_duration = io_cycles - io1_duration if io_cycles > 0 else 0
                io2_start = compute_start + compute_cycles
                ax2.broken_barh([(io2_start, io2_duration)], (y_ticks[2] - bar_height/2, bar_height), facecolors=colors['PIM_IO'])
                # Bus is busy during PIM IO
                ax2.broken_barh([(io2_start, io2_duration)], (y_ticks[1] - bar_height/2, bar_height), facecolors=colors['BUS_DATA'])

                # Micro Overhead Phase (occurs after Store)
                micro_start = io2_start + io2_duration
                ax2.broken_barh([(micro_start, micro_overhead)], (y_ticks[2] - bar_height/2, bar_height), facecolors=colors['PIM_MICRO'])

            max_time_seq = max(max_time_seq, pim_end, cpu_end) # Track max time

        ax2.set_xlim(0, max_time_seq * 1.05) # Add 5% padding
    else:
        ax2.text(0.5, 0.5, 'No Sequencer Data', ha='center', va='center', transform=ax2.transAxes)

    ax2.set_xlabel('Execution Time (Clock Cycles)', fontsize=12)

    # --- Create Custom Legend ---
    legend_elements = [
        Patch(facecolor=colors['CPU_ISSUE'], label='CPU Active (Issue Cmd/Burst)'),
        Patch(facecolor=colors['CPU_STALL'], alpha=0.7, label='CPU Stall (Waiting)'),
        Patch(facecolor=colors['BUS_CMD'], label='Bus Busy (Cmd Transfer)'),
        Patch(facecolor=colors['BUS_DATA'], label='Bus Busy (PIM Data Transfer)'),
        Patch(facecolor=colors['PIM_IO'], label='PIM Active (IO Operation)'),
        Patch(facecolor=colors['PIM_COMPUTE'], label='PIM Active (Compute Operation)'),
        Patch(facecolor=colors['PIM_MICRO'], label='PIM Active (Sequencer Overhead)')
    ]
    fig.legend(handles=legend_elements, loc='lower center', ncol=4, bbox_to_anchor=(0.5, -0.05), fontsize=10)

    plt.tight_layout(rect=[0, 0.03, 1, 0.95]) # Adjust rect to make space for legend and title

    # --- Save Plot ---
    os.makedirs(output_dir, exist_ok=True) # Ensure directory exists
    save_path = os.path.join(output_dir, 'gantt_chart_comparison.png')
    try:
        fig.savefig(save_path, dpi=150)
        print(f"\nGantt chart visualization saved to: {os.path.abspath(save_path)}")
    except Exception as e:
        print(f"Error saving Gantt chart: {e}")

    plt.show() # Display the plot

if __name__ == '__main__':
    plot_gantt_chart(csv_path='simulation/results/traces.csv',
                     output_dir='simulation/results')